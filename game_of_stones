#!/usr/bin/python3

import sys
import argparse
import re
import math
from collections import deque

# ========== Classes de base ==========

class ArgumentParser(argparse.ArgumentParser):
    """
    Custom ArgumentParser pour gérer plus finement certaines erreurs.
    """
    def _get_action_from_name(self, name):
        container = self._actions
        if name is None:
            return None
        for action in container:
            if '/'.join(action.option_strings) == name:
                return action
            elif action.metavar == name:
                return action
            elif action.dest == name:
                return action
        return None

    def error(self, message):
        exc = sys.exc_info()[1]
        if exc:
            exc.argument = self._get_action_from_name(exc.argument_name)
            raise exc
        super(ArgumentParser, self).error(message)

class Node:
    """
    Représente un personnage, ses amis et ceux qu'il complote contre.
    """
    def __init__(self, name: str):
        self.name = name
        self.friends = []        # liste de Node (graphe non orienté)
        self.depth = -1          # utilisé dans BFS/DFS pour calculer la distance
        # Remarque: on ne stocke pas ici conspiration dans le Node
        #           car on gérera le graphe de complots séparément

    def add_friend(self, friend: 'Node'):
        """Ajoute une relation d'amitié bi-directionnelle."""
        if friend.name == self.name:
            raise ValueError("Cannot be friend with himself")
        if friend not in self.friends:
            self.friends.append(friend)
        if self not in friend.friends:
            friend.friends.append(self)

class Graph:
    """
    Représente le graphe des amis (non orienté).
    On stocke aussi la liste globale des personnages.
    """
    def __init__(self):
        self.nodes = []

    def add_node(self, node: Node):
        if node not in self.nodes:
            self.nodes.append(node)
        else:
            raise ValueError("Node already exists")

    def find_node(self, name: str) -> Node:
        for node in self.nodes:
            if node.name == name:
                return node
        return None

# ========== Parsing des fichiers ==========

def is_valid_format(line: str):
    """
    Vérifie si la ligne correspond au format: "<pers> is friends with <pers>"
    Retourne [p1, p2] ou None.
    """
    pattern = r'^(\S.*) is friends with (\S.*)$'
    match = re.match(pattern, line)
    if match:
        return [match.group(1).strip(), match.group(2).strip()]
    return None

def is_valid_plot_format(line: str):
    """
    Vérifie si la ligne correspond au format: "<pers> is plotting against <pers>"
    Retourne [p1, p2] ou None.
    """
    pattern = r'^(\S.*) is plotting against (\S.*)$'
    match = re.match(pattern, line)
    if match:
        return [match.group(1).strip(), match.group(2).strip()]
    return None

def read_file(file: str) -> list:
    try:
        with open(file, 'r') as f:
            return f.readlines()
    except FileNotFoundError:
        raise FileNotFoundError(f"File {file} not found")

def get_list_pair_friend(friends_list: list):
    l = []
    for line in friends_list:
        line = line.strip()
        if not line:
            continue
        a = is_valid_format(line)
        if a is not None:
            l.append(a)
        else:
            raise ValueError(f"Invalid format in friendship file: {line}")
    return l

def get_list_pair_conspiracy(conspiracy_list: list):
    l = []
    for line in conspiracy_list:
        line = line.strip()
        if not line:
            continue
        a = is_valid_plot_format(line)
        if a is not None:
            l.append(a)
        else:
            raise ValueError(f"Invalid format in conspiracy file: {line}")
    return l

def find_or_create(graph: Graph, name: str) -> Node:
    node = graph.find_node(name)
    if node is None:
        node = Node(name)
        graph.add_node(node)
    return node

# ========== BFS/Distances d'amitié ==========

def bfs_all_distances(graph: Graph, start: Node) -> dict:
    """
    Retourne un dict node->distance indiquant la plus courte distance
    d'amitié entre 'start' et chaque autre Node.
    """
    for node in graph.nodes:
        node.depth = -1

    dist = {}
    queue = deque()
    start.depth = 0
    dist[start] = 0
    queue.append(start)

    while queue:
        current = queue.popleft()
        for friend in current.friends:
            if friend.depth == -1:
                friend.depth = current.depth + 1
                dist[friend] = friend.depth
                queue.append(friend)
    return dist

def bfs_distance(graph: Graph, start: Node, end: Node) -> int:
    """
    Retourne la distance d'amitié la plus courte entre 'start' et 'end'.
    """
    # Réinitialise la profondeur
    for node in graph.nodes:
        node.depth = -1

    queue = deque()
    start.depth = 0
    queue.append(start)

    while queue:
        current = queue.popleft()
        if current == end:
            return current.depth
        for friend in current.friends:
            if friend.depth == -1:
                friend.depth = current.depth + 1
                queue.append(friend)
    return -1

# ========== Mode --links ==========

def links(fr: str, p1: str, p2: str, graph: Graph):
    """
    Mode: affiche le degré de séparation en amitié entre p1 et p2.
    """
    friends_list = read_file(fr)
    if len(friends_list) == 0:
        raise ValueError("Empty friendship file")

    # Construction du graphe d'amis
    listPairs = get_list_pair_friend(friends_list)
    for pair in listPairs:
        n1 = find_or_create(graph, pair[0])
        n2 = find_or_create(graph, pair[1])
        n1.add_friend(n2)

    NodeP1 = graph.find_node(p1)
    NodeP2 = graph.find_node(p2)

    if NodeP1 is None or NodeP2 is None:
        print(f"Degree of separation between {p1} and {p2}: -1")
        return

    dist = bfs_distance(graph, NodeP1, NodeP2)
    print(f"Degree of separation between {p1} and {p2}: {dist}")

# ========== Mode --plots : logique de complot avancée ==========

def gather_plots(cr_file: str, graph: Graph):
    """
    Lit le fichier de complots, construit la structure:
      plotsAgainst[A] = {B1, B2, ...}
    si A complote contre B1, B2, ...
    Vérifie que chaque cible existe dans le graph d'amis.
    """
    conspiracies_list = read_file(cr_file)
    if len(conspiracies_list) == 0:
        raise ValueError("Empty conspiracies file")

    listConspiracies = get_list_pair_conspiracy(conspiracies_list)
    plotsAgainst = {}
    for A, B in listConspiracies:
        # Vérifie l'existence de B dans le graph
        if graph.find_node(B) is None:
            # Erreur si la cible n'est pas dans le FR
            print(f"An error occurred: {B} not found in friendships file", file=sys.stderr)
            sys.exit(84)
        if A not in plotsAgainst:
            plotsAgainst[A] = set()
        plotsAgainst[A].add(B)
    return plotsAgainst

def find_direct_enemies(queenName: str, plotsAgainst: dict) -> list:
    """
    Renvoie la liste (unique, triée) des ennemis directs de la reine:
    ceux qui complotent explicitement contre queenName.
    """
    direct = []
    for conspirator, targets in plotsAgainst.items():
        if queenName in targets:
            direct.append(conspirator)
    return sorted(set(direct))

# ========== Recherche récursive de chaînes de complot ==========

def kill_enemy(
    E: str,                          # l'ennemi à tuer
    graph: Graph,
    plotsAgainst: dict,             # dict: A -> set(B,...) si A complote contre B
    dist_from_queen: dict,          # dict: Node -> distance par rapport à la reine
    n: int,                         # distance d'amitié max
    used: set,                      # ensemble de noms déjà utilisés dans la chaîne
    direct_enemies: set
):
    """
    Retourne **toutes les chaînes** permettant de tuer E.
    Une "chaîne" est une liste de noms [X1, X2, ..., Xk] se terminant
    par "-> E", indiquant Xk -> E (Xk tue E). En pratique, on stocke la suite
    d'actions sous la forme: [("Xk","E"), ...] ou sous une structure plus lisible.

    Logique:
    1) On cherche tout conspirateur X tel que X complote contre E.
    2) S'il n'existe pas, on ne peut pas tuer E => renvoie [].
    3) Pour chaque X:
       - Si X est déjà "used" dans cette chaîne => on l'ignore (éviter boucles).
       - On calcule la distance d'amitié de X à la reine (distX).
         * Si distX <= n => X est un "close friend"; on peut l'utiliser
           directement: la chaîne = [X -> E].
         * Sinon => X est "far friend". Pour qu'il nous aide,
           on doit "tuer" au moins un de ses ennemis (Y tel que Y complote contre X),
           ce qui nous met X dans la poche.
           - On cherche ces Y (potentiels "indirect enemies").
           - Pour chaque Y, on appelle kill_enemy(Y, ...) récursivement.
           - Si au moins un Y peut être tué, alors X s'allie et tue E.
    4) On agrège toutes les chaînes trouvées et on les renvoie.
    """
    # Sécurité: si E déjà "used" dans la chaîne, on stoppe (éviter re-boucle).
    if E in used:
        return []

    # Cherche dans plotsAgainst tous les X qui complotent contre E
    conspirators = []
    for X, targets in plotsAgainst.items():
        if E in targets:
            conspirators.append(X)

    if not conspirators:
        # Personne ne complote contre E => E n'est pas tuable
        return []

    all_chains = []

    # Tri préalable selon les règles de priorité:
    # 1) X n'est pas un ennemi direct => prioritaire
    # 2) ensuite distance(X, queen)
    # 3) enfin ordre alphabétique
    def priority(x):
        node_x = graph.find_node(x)
        dist_x = dist_from_queen.get(node_x, math.inf)
        # 1) bool: x not in direct_enemies => plus prioritaire => on inverse True/False
        is_not_enemy = (x not in direct_enemies)
        # On met un tri lex: d'abord -is_not_enemy (pour que True soit avant False),
        # puis dist_x, puis x.
        return (-int(is_not_enemy), dist_x, x)

    conspirators.sort(key=priority)

    for X in conspirators:
        if X in used:
            continue

        node_x = graph.find_node(X)
        dist_x = dist_from_queen.get(node_x, math.inf)
        if dist_x <= n:
            # X est un "close friend" => X -> E direct
            chain = [(X, E)]
            all_chains.append(chain)
        else:
            # X est trop loin => on doit le convaincre
            # On cherche les Y qui complotent contre X
            # (car si on tue Y, X nous doit un "service")
            if X not in plotsAgainst:
                # X ne fait que comploter, mais personne ne complote contre X => pas tuable ?
                # Dans la logique "someone plotting against a far friend is an indirect enemy"
                # => il nous faut un Y s'il existe
                continue
            # Qui sont les Y qui complotent X ?
            # Correction : c'est l'inverse qu'il faut, "Y" tel que Y in plotsAgainst, et X in plotsAgainst[Y] => Y complote X
            # Donc on doit boucler sur plotsAgainst pour trouver Y dont la cible est X.
            killers_of_X = []
            for possibleY, targetsY in plotsAgainst.items():
                if X in targetsY:
                    killers_of_X.append(possibleY)

            if not killers_of_X:
                # Personne ne complote contre X => on ne peut pas tuer un ennemi de X
                continue

            # Pour chaque Y, on tente de tuer Y récursivement
            success_for_X = []
            for Y in killers_of_X:
                if Y in used:
                    continue
                # On lance la recursion
                # Ajoute X dans used pour qu'on ne le réutilise pas durant la sous-chaîne
                # ou on l'ajoute après le chain ? => On ne veut pas boucler sur X non plus.
                new_used = used.union({X})
                sub_chains = kill_enemy(Y, graph, plotsAgainst, dist_from_queen, n, new_used, direct_enemies)
                # sub_chains est une liste de chaînes qui tuent Y
                for sub_chain in sub_chains:
                    # sub_chain est une suite [(A->B), (C->Y)]
                    # Ensuite X -> E
                    # On combine
                    chain = sub_chain + [(X, E)]
                    success_for_X.append(chain)

            all_chains.extend(success_for_X)

    return all_chains

def build_solution_for_enemy(
    E: str,
    graph: Graph,
    plotsAgainst: dict,
    dist_from_queen: dict,
    n: int,
    direct_enemies: set
):
    """
    Tente de construire *toutes* les chaînes pour tuer E (ennemi direct).
    Retourne une liste de chaînes (liste de tuples).
    Puis on les trie par longueur, puis lexicographiquement.
    """
    # On démarre avec used = { } (personnes déjà impliquées).
    raw_chains = kill_enemy(E, graph, plotsAgainst, dist_from_queen, n, used=set(), direct_enemies=direct_enemies)

    # Tri final: d'abord la taille de la chaîne (croissant), puis ordre "alphabet"
    # On transforme la chaîne [(X1,E1), (X2,E2), ...] en version "liste de noms" pour comparer
    # lexicalement. Par ex. "X1->E1 X2->E2"
    def chain_to_str(ch):
        return " ".join(f"{x}->{e}" for (x,e) in ch)

    raw_chains.sort(key=lambda ch: (len(ch), chain_to_str(ch)))
    return raw_chains

def plots(fr: str, cr: str, n: int):
    """
    Mode: lecture du FR (amis) + CR (complots), application complète de la logique:
      - Construction & affichage de la matrice (distance ≤ n ou 0, inaccessible => -1).
      - Recherche des ennemis directs de la reine.
      - Pour chaque ennemi direct E, on tente de trouver au moins une chaîne de complot.
      - S'il manque une chaîne pour un E => trahison.
      - Sinon => The stone is safe!
    """
    # 1) Construction du graphe d'amis
    friends_list = read_file(fr)
    if len(friends_list) == 0:
        raise ValueError("Empty friendship file")
    graph = Graph()

    listPairs = get_list_pair_friend(friends_list)
    for pair in listPairs:
        n1 = find_or_create(graph, pair[0])
        n2 = find_or_create(graph, pair[1])
        n1.add_friend(n2)

    # 2) Construction de plotsAgainst
    plotsAgainst = gather_plots(cr, graph)

    # 3) Affichage des noms
    sorted_names = sorted(node.name for node in graph.nodes)
    print("Names:")
    for name in sorted_names:
        print(name)
    print()

    # 4) Matrice d'amitié (Relationships)
    print("Relationships:")
    for name1 in sorted_names:
        src_node = graph.find_node(name1)
        dist_dict = bfs_all_distances(graph, src_node)
        row_parts = []
        for name2 in sorted_names:
            dst_node = graph.find_node(name2)
            if dst_node in dist_dict:
                d = dist_dict[dst_node]
                if d <= n:
                    row_parts.append(str(d))
                else:
                    row_parts.append("0")
            else:
                row_parts.append("-1")
        print(" ".join(row_parts))
    print()

    # 5) Analyse des complots
    print("Conspiracies:")

    queenName = "Cersei Lannister"
    queenNode = graph.find_node(queenName)
    if queenNode is None:
        print("No queen in the graph => no resolution possible.")
        print()
        print("Result:")
        print("There is only one way out: treason!")
        return

    # Distances de chaque node à la reine
    dist_from_queen = bfs_all_distances(graph, queenNode)

    # 6) Identifier les ennemis directs
    direct_enemies_list = find_direct_enemies(queenName, plotsAgainst)
    direct_enemies_set = set(direct_enemies_list)

    # On va stocker TOUTES les chaînes utilisées pour *chaque* ennemi
    # (dans cette version, nous n'imposons pas que les chaînes soient mutuellement exclusives,
    #  c.-à-d. on n'interdit pas qu'une personne serve à tuer plusieurs ennemis.)
    # => on suit l'énoncé "In one chain of conspiracy, you cannot plot with or against
    #    the same person twice", ce qui est géré localement par kill_enemy().

    all_solutions = {}  # E -> liste de chaînes

    for E in direct_enemies_list:
        chains_for_E = build_solution_for_enemy(
            E, graph, plotsAgainst, dist_from_queen, n, direct_enemies_set
        )
        all_solutions[E] = chains_for_E

    # 7) Vérifie s'il existe au moins une solution pour chaque E
    #    On affiche la "première" (courte / alphabétique) pour chaque E
    #    selon l'exemple d'affichage.
    success = True
    used_for_display = []

    for E in direct_enemies_list:
        solutions = all_solutions[E]
        if not solutions:
            # Aucune façon de tuer E
            success = False
        else:
            # On prend la première chaîne (la plus courte, tri alphabétique)
            best_chain = solutions[0]
            # On l'affiche sous la forme "X -> E" ou "A->B -> C->D -> E->F"
            # Mais selon l'énoncé, souvent on affiche juste "X -> E".
            # S'il y a un chain plus complexe, on le liste "A->B  C->D  X->E"
            # ou dans un format plus lisible.
            # Pour rester cohérent avec l'exemple, on peut tout afficher sur une ligne.
            # Mais l'énoncé donne souvent un affichage multi-ligne.
            # Ici on va faire un affichage multi-ligne:
            #    A -> B -> ...
            #    ...
            # Pour coller aux exemples fournis par l'énoncé, on simplifie
            # en imprimant successivement:
            #    A -> B
            #    C -> D
            # etc.
            chain_str_parts = []
            for (x, y) in best_chain:
                if not chain_str_parts:
                    chain_str_parts.append(x)
                chain_str_parts.append(y)

            chain_str = " -> ".join(chain_str_parts)
            print(chain_str)
            # Séparateur visuel
            # (facultatif, on peut laisser sans saut de ligne, selon l'esthétique voulue)
            # print("--")

    if not success:
        # Afficher ceux qui n'ont pas été neutralisés
        not_killed = [E for E in direct_enemies_list if not all_solutions[E]]
        if len(not_killed) > 0:
            print(f"No conspiracy possible against: {', '.join(not_killed)}")
        print()
        print("Result:")
        print("There is only one way out: treason!")
    else:
        print()
        print("Result:")
        print("The stone is safe!")

# ========== main ==========

def main() -> int:
    # Vérifie la forme générale de la ligne de commande
    if len(sys.argv) != 5:
        raise ValueError("Invalid number of arguments")

    parser = ArgumentParser(
        usage='./game_of_stones [--links FR P1 P2 | --plots FR CR n]',
        description='Game of Stones command line tool'
    )
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--links', nargs=3, metavar=('FR', 'P1', 'P2'),
                       help='FR: file containing friendship relations, P1: person one, P2: person two')
    group.add_argument('--plots', nargs=3, metavar=('FR', 'CR', 'n'),
                       help='FR: file with friendship relations, CR: file with conspiracies intentions, n: max friendship path length')
    graph = Graph()

    args = parser.parse_args()

    if args.links:
        fr, p1, p2 = args.links
        links(fr, p1, p2, graph)

    elif args.plots:
        fr, cr, n_str = args.plots
        if not n_str.isdigit() or int(n_str) <= 0:
            raise ValueError("n must be a positive number")
        n = int(n_str)
        plots(fr, cr, n)

    return 0

if __name__ == '__main__':
    try:
        main()
        sys.exit(0)
    except Exception as e:
        print(f"An error occurred: {e}", file=sys.stderr)
        sys.exit(84)
