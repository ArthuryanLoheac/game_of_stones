#!/usr/bin/python3

from collections import deque
import sys
import math
import argparse
import re

# ========== Classes ==========

class ArgumentParser(argparse.ArgumentParser):    
    """
    Custom ArgumentParser pour gérer plus finement certaines erreurs.
    """
    def _get_action_from_name(self, name):
        container = self._actions
        if name is None:
            return None
        for action in container:
            if '/'.join(action.option_strings) == name:
                return action
            elif action.metavar == name:
                return action
            elif action.dest == name:
                return action
        return None

    def error(self, message):
        exc = sys.exc_info()[1]
        if exc:
            exc.argument = self._get_action_from_name(exc.argument_name)
            raise exc
        super(ArgumentParser, self).error(message)

class Node:
    """
    Représente un personnage, ses amis et ceux qu'il complote contre.
    """
    def __init__(self, name: str):
        self.name = name
        self.friends = []        # liste de Node (amitiés)
        self.conspiration = []   # liste de Node (complots orientés)
        self.depth = -1          # utilisé pour BFS si nécessaire

    def add_friend(self, friend: 'Node'):
        """Ajoute une relation d'amitié bi-directionnelle."""
        if friend.name == self.name:
            raise ValueError("Cannot be friend with himself")
        if friend not in self.friends:
            self.friends.append(friend)
        if self not in friend.friends:
            friend.friends.append(self)

    def add_conspiration(self, conspiration: 'Node'):
        """Ajoute un complot (orienté)."""
        if conspiration.name == self.name:
            raise ValueError("Cannot be conspiration with himself")
        if conspiration not in self.conspiration:
            self.conspiration.append(conspiration)

class Graph:
    """
    Le graphe global : liste de Node et, éventuellement, référence à la reine.
    """
    def __init__(self):
        self.nodes = []
        self.QueenNode = None

    def add_node(self, node: Node):
        if node not in self.nodes:
            self.nodes.append(node)
        else:
            raise ValueError("Node already exists")

    def add_queen(self, node: Node):
        """Spécifie qui est la reine (optionnel)."""
        if self.QueenNode is not None:
            raise ValueError("Queen already exists")
        self.QueenNode = node
        self.add_node(node)

    def find_node(self, name: str) -> Node:
        """
        Retourne le Node portant le nom 'name', ou None si introuvable.
        """
        for node in self.nodes:
            if node.name == name:
                return node
        return None

# ========== Functions Utilitaires ==========

def is_valid_format(line: str):
    """
    Vérifie si la ligne correspond au format:
      "<personne> is friends with <personne>"
    Retourne [personne1, personne2] ou None.
    """
    pattern = r'^(\S.*) is friends with (\S.*)$'
    match = re.match(pattern, line)
    if match:
        return [match.group(1).strip(), match.group(2).strip()]
    return None

def read_file(file: str) -> list:
    """
    Lit un fichier et renvoie la liste brute des lignes.
    Lève FileNotFoundError si le fichier n'existe pas.
    """
    try:
        with open(file, 'r') as f:
            return f.readlines()
    except FileNotFoundError:
        raise FileNotFoundError(f"File {file} not found")

def get_list_pair_friend(friends_list: list):
    """
    Parse chaque ligne du fichier d'amitiés et retourne les paires [p1, p2].
    """
    l = []
    for line in friends_list:
        line = line.strip()
        if not line:
            continue
        a = is_valid_format(line)
        if a is not None:
            l.append(a)
        else:
            raise ValueError(f"Invalid format in file: {line}")
    return l

def find_or_create(graph: Graph, name: str) -> Node:
    """
    Cherche le nœud 'name' dans graph, le crée s'il n'existe pas encore.
    Renvoie le Node correspondant.
    """
    node = graph.find_node(name)
    if node is None:
        node = Node(name)
        graph.add_node(node)
    return node

# ========== BFS Functions ==========

def bfs_distance(graph: Graph, start: Node, end: Node) -> int:
    """
    Calcule la plus courte distance (en nb d'arêtes) entre start et end via BFS.
    Retourne -1 si end n'est pas accessible.
    """
    # Remise à zéro des depths
    for node in graph.nodes:
        node.depth = -1

    from collections import deque
    queue = deque()
    start.depth = 0
    queue.append(start)

    while queue:
        current = queue.popleft()
        if current == end:
            return current.depth  # On a trouvé la cible, c'est la distance min
        for friend in current.friends:
            if friend.depth == -1:
                friend.depth = current.depth + 1
                queue.append(friend)

    return -1  # end n'a pas été trouvé

def bfs_all_distances(graph: Graph, start: Node) -> dict:
    """
    Calcule la distance minimale entre 'start' et tous les autres nœuds
    via BFS. Renvoie un dict { node: distance }.
    Si un nœud n'est pas joignable, il ne figurera pas dans le dict.
    """
    # Remise à zéro des depths
    for node in graph.nodes:
        node.depth = -1

    dist = {}
    from collections import deque
    queue = deque()
    start.depth = 0
    queue.append(start)
    dist[start] = 0

    while queue:
        current = queue.popleft()
        for friend in current.friends:
            if friend.depth == -1:
                friend.depth = current.depth + 1
                dist[friend] = friend.depth
                queue.append(friend)

    return dist

# ========== Modes ==========

def links(fr: str, p1: str, p2: str, graph: Graph):
    """
    Mode --links :
      1) Lit le fichier FR et construit le graphe des amitiés
      2) Calcule BFS pour obtenir la distance entre p1 et p2
      3) Affiche le résultat
    """
    friends_list = read_file(fr)
    if len(friends_list) == 0:
        raise ValueError("Empty file")

    listPairs = get_list_pair_friend(friends_list)
    # Construction du graphe
    for pair in listPairs:
        n1 = find_or_create(graph, pair[0])
        n2 = find_or_create(graph, pair[1])
        n1.add_friend(n2)

    NodeP1 = graph.find_node(p1)
    NodeP2 = graph.find_node(p2)

    # Si p1 ou p2 n'existe pas dans le graphe
    if NodeP1 is None or NodeP2 is None:
        print(f"Degree of separation between {p1} and {p2}: -1")
        return

    # BFS distance
    dist = bfs_distance(graph, NodeP1, NodeP2)
    print(f"Degree of separation between {p1} and {p2}: {dist}")

def plots(fr: str, cr: str, n: int):
    """
    Mode --plots :
      1) Lit FR => construit le graphe des amitiés
      2) Lit CR => construit le graphe des complots
      3) Affiche la liste alphabétique des noms
      4) Construit la matrice de distances (≤ n => distance, > n => 0, non joignable => -1)
      5) Détermine les conspirations utiles pour sauver la reine (ou conclut à la trahison).
    """
    # 1) Construction du graphe d'amitiés
    friends_list = read_file(fr)
    if len(friends_list) == 0:
        raise ValueError("Empty file")

    listPairs = get_list_pair_friend(friends_list)
    graph = Graph()
    for pair in listPairs:
        n1 = find_or_create(graph, pair[0])
        n2 = find_or_create(graph, pair[1])
        n1.add_friend(n2)

    # 2) Lecture et construction du graphe (orienté) de complots
    conspiracies_list = read_file(cr)
    if len(conspiracies_list) == 0:
        raise ValueError("Empty file")

    # Dictionnaire : victime -> set(conspirateurs)
    from collections import defaultdict
    victim_to_conspirators = defaultdict(set)

    # On parcourt chaque ligne "A is plotting against B"
    pattern_plots = r'^(\S.*) is plotting against (\S.*)$'
    for line in conspiracies_list:
        line = line.strip()
        if not line:
            continue
        match = re.match(pattern_plots, line)
        if not match:
            raise ValueError(f"Invalid format in CR file: {line}")
        A_name = match.group(1).strip()
        B_name = match.group(2).strip()

        # Vérifie que A et B existent dans le graphe FR
        A_node = graph.find_node(A_name)
        B_node = graph.find_node(B_name)
        if A_node is None or B_node is None:
            # Personne inconnue dans FR => erreur
            raise ValueError(f"Person {A_name if A_node is None else B_name} "
                             f"from CR not found in FR")
        # Ajout dans la structure de complot
        A_node.add_conspiration(B_node)
        victim_to_conspirators[B_name].add(A_name)

    # 3) Affichage des noms en ordre alphabétique
    sorted_names = sorted(node.name for node in graph.nodes)
    print("Names:")
    for name in sorted_names:
        print(name)
    print()

    # 4) Matrice des distances d'amitié (≤ n => distance, > n => 0, pas joignable => -1)
    print("Relationships:")
    for name1 in sorted_names:
        src_node = graph.find_node(name1)
        dist_dict = bfs_all_distances(graph, src_node)  # {nodeObj: distance}

        row_parts = []
        for name2 in sorted_names:
            dst_node = graph.find_node(name2)
            if dst_node in dist_dict:
                d = dist_dict[dst_node]
                row_parts.append(str(d if d <= n else 0))
            else:
                row_parts.append(str(-1))
        print(" ".join(row_parts))
    print()

    # 5) Détermination des conspirations qui neutralisent les ennemis directs de la reine
    print("Conspiracies:")

    queen_name = "Cersei Lannister"  # On suppose la reine nommée ainsi
    queen_node = graph.find_node(queen_name)
    if queen_node is None:
        # Si la reine n'existe pas dans FR, on ne peut rien faire
        print("Result:")
        print("There is only one way out: treason!")
        return

    # (a) On calcule les distances de tous à la reine (pour la priorité #2)
    dist_dict_queen = bfs_all_distances(graph, queen_node)  # { NodeObj: distance }

    def distance_to_queen(person_name: str) -> int:
        """Retourne la distance d'amitié jusqu'à la reine (ou un grand nombre si non joignable)."""
        node = graph.find_node(person_name)
        if node in dist_dict_queen:
            return dist_dict_queen[node]
        return 999999  # Non joignable => on met un énorme nombre

    def is_enemy(person_name: str) -> bool:
        """
        Renvoie True si cette personne complote DIRECTEMENT contre la reine.
        Autrement dit, si queen_name est victime de 'person_name'.
        """
        return person_name in victim_to_conspirators[queen_name]

    # (b) Liste des ennemis directs : tous ceux qui complotent contre la reine
    direct_enemies = sorted(victim_to_conspirators[queen_name])

    # On va essayer de trouver un conspirateur pour chaque ennemi direct
    conspiracies_used = []
    cannot_neutralize = False

    for enemy_name in direct_enemies:
        # Ensemble de gens qui complotent contre cet ennemi
        conspirators = victim_to_conspirators[enemy_name]
        if not conspirators:
            # Personne ne le vise => impossible à neutraliser
            print(f"No conspiracy possible against {enemy_name}")
            cannot_neutralize = True
            continue

        # Tri des conspirateurs selon la priorité demandée :
        # (pas ennemi => 0, si ennemi => 1), distance à la reine, ordre alphabétique
        sorted_candidates = sorted(
            conspirators,
            key=lambda c: (
                1 if is_enemy(c) else 0,            # d'abord ceux qui NE sont pas ennemis
                distance_to_queen(c),
                c
            )
        )

        best = sorted_candidates[0]
        conspiracies_used.append((best, enemy_name))

    # (c) Affichage des conspirations utiles, triées selon l'ordre alphabétique du conspirateur
    #     (pour reproduire l'exemple officiel).
    conspiracies_used.sort(key=lambda x: x[0])  # x[0] est le conspirateur
    for (c_name, e_name) in conspiracies_used:
        # Si on n'a pas trouvé de conspirateur viable pour e_name, on n'ajoute pas
        # Dans la boucle ci-dessus, on n'ajoute que si conspirators n'est pas vide.
        print(f"{c_name} -> {e_name}")

    print()
    print("Result:")
    if cannot_neutralize:
        print("There is only one way out: treason!")
    else:
        print("The stone is safe!")


# ========== Main ==========

def main() -> int:
    """
    Point d'entrée. On utilise la classe custom ArgumentParser pour parser.
    """
    if len(sys.argv) != 5:
        raise ValueError("Invalid number of arguments")

    parser = ArgumentParser(
        usage='./game_of_stones [--links FR P1 P2 | --plots FR CR n]',
        description='Game of Stones command line tool'
    )
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--links', nargs=3, metavar=('FR', 'P1', 'P2'),
                       help='FR: file containing friendship relations, P1: person one, P2: person two')
    group.add_argument('--plots', nargs=3, metavar=('FR', 'CR', 'n'),
                       help='FR: file with friendship relations, CR: file with conspiracies intentions, n: max friendship path length')
    graph = Graph()
    
    args = parser.parse_args()

    # Selon le mode
    if args.links:
        fr, p1, p2 = args.links
        links(fr, p1, p2, graph)

    elif args.plots:
        fr, cr, n = args.plots
        if not n.isdigit() or int(n) <= 0:
            raise ValueError("n must be a positive number")
        plots(fr, cr, int(n))

    return 0

if __name__ == '__main__':
    try:
        main()
        sys.exit(0)
    except Exception as e:
        print(f"An error occurred: {e}", file=sys.stderr)
        sys.exit(84)
